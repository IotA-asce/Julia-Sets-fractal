"""
[DESCRIPTION]
The Julia set fractal is a mathematical object that is generated by iterating a
complex function and checking if the resulting sequence stays bounded or not.
The function that is typically used is of the form 

    f(_z) = _z^2 + c,     where _z is a complex number and c is a constant.

The value of c determines the shape of the resulting fractal.

[GENERATION]

-   To generate the fractal we start with a complex number _z and iterate the function
    f(_z) repeteadly, replacing _z with f(_z) each time.

    -   We then check if the magnitude of the resulting number stays below a
        certain threshold value.
    -   if it does, then we color the corresponding pixel in the image black.
    -   if it does not, then we color the corresponding pixel in the image with a 
        color based on how many iterations it took for the magnitude to go above 
        the threshold value

-   The constant value of c is chosen with mouse position recorded at mouse click

"""
import sys
import pygame

from complex import Complex

C = Complex(_re=0, _im=0)

# Global constants representing the size and offset of the grid
GRID_SIZE = (1000, 1000)
OFFSET = (GRID_SIZE[0]/2, GRID_SIZE[1]/2)

THRESHOLD = 4

def create_grid():
    """
    Create a 2D grid of complex numbers

    The grid is a 2D list of Complex numbers, with the size specified by the `GRID_SIZE`
    variable. The grid is offset so that the centre of the grid is located at (0, 0).

    returns:
    list: A 2D list of Complex numbers representing coordinates on the grid
    """

    grid = []

    for _row in range(GRID_SIZE[0]):
        grid_row = []
        for _col in range(GRID_SIZE[1]):
            _coord = Complex((_row - OFFSET[0]) / 200, (_col - OFFSET[1]) / 200)
            grid_row.append(_coord)

        grid.append(grid_row)

    return grid

def fractal(_z=Complex(_re=0, _im=0)):
    """
    computes the fractal exponent
    """

    return _z.exponential(2) + C        # C is the constant Complex number

def compute_jumps(_z=Complex(_re=0, _im=0)):
    """
    UNDOCUMENTED
    """
    iteration_count = 0

    while _z.magnitude() < THRESHOLD and iteration_count < 10:
        iteration_count += 1

        _z = fractal(_z)
    
    return iteration_count

def compute():
    """
    [UNDOCUMEnTED]
    """

    # creating the grid
    complex_grid = create_grid()
    color_grid = create_grid()

    for _row in range(GRID_SIZE[0]):
        for _col in range(GRID_SIZE[1]):
            color_grid[_row][_col] = compute_jumps(complex_grid[_row][_col])

    return complex_grid, color_grid

def print_out(_grid, _name):
    f = open(f"{_name}.txt", "a", encoding='UTF-8')
    for _row in _grid:
        f.write(str(_row) + "\n")


def paint():
    """
    undocumented
    """

    complex_grid, shade_grid = compute()

    # print_out(complex_grid, "complex")
    # print_out(shade_grid, "shade")

    pygame.init()

    screen = pygame.display.set_mode(GRID_SIZE)
    screen.fill("Black")

    clock = pygame.time.Clock()

    while True:

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN:
                _x, _y = pygame.mouse.get_pos()
                C.set(_re=(_x - OFFSET[0]), _im=(_y - OFFSET[1]))
                complex_grid, shade_grid = compute()

                print(_x, _y)

        for _row in range(GRID_SIZE[0]):
            for _col in range(GRID_SIZE[1]):
                shade = 255 - (shade_grid[_row][_col] * 20)

                surface = pygame.Surface((1, 1))
                surface.fill(shade)
                screen.blit(surface, (_row, _col))
        pygame.display.update()
        clock.tick(1)

paint()
