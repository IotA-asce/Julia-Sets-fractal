"""
[DESCRIPTION]
The Julia set fractal is a mathematical object that is generated by iterating a
complex function and checking if the resulting sequence stays bounded or not.
The function that is typically used is of the form 

    _f(_z) = _z^2 + c,     where _z is a complex number and c is a constant.

The value of c determines the shape of the resulting fractal.

[GENERATION]

-   To generate the fractal we start with a complex number _z and iterate the function
    _f(_z) repeteadly, replacing _z with _f(_z) each time.

    -   We then check if the magnitude of the resulting number stays below a
        certain threshold value.
    -   if it does, then we color the corresponding pixel in the image black.
    -   if it does not, then we color the corresponding pixel in the image with a 
        color based on how many iterations it took for the magnitude to go above 
        the threshold value

-   The constant value of c is chosen with mouse position recorded at mouse click

"""
import sys
import pygame
import numpy as np
import os

from complex import Complex

# C = Complex(_re=-0.4, _im=0.6)
# -0.4, 0.6

# Global constants representing the size and offset of the grid
RESOLUTION = 1000
GRID_SIZE = (RESOLUTION, RESOLUTION)
SCREEN_SIZE = (1000, 1000)
OFFSET = (GRID_SIZE[0]/2, GRID_SIZE[1]/2)

ZOOM_FACTOR = OFFSET[0] / 2
THRESHOLD = 2

def create_grid():
    """
    Create a 2D grid of complex numbers

    The grid is a 2D list of Complex numbers, with the size specified by the `GRID_SIZE`
    variable. The grid is offset so that the centre of the grid is located at (0, 0).

    returns:
    list: A 2D list of Complex numbers representing coordinates on the grid
    """

    grid = []

    for _row in range(GRID_SIZE[0]):
        grid_row = []
        for _col in range(GRID_SIZE[1]):
            # _coord = Complex((_row - OFFSET[0]) / ZOOM_FACTOR, (_col - OFFSET[1]) / ZOOM_FACTOR)
            _coord = complex((_row - OFFSET[0]) / ZOOM_FACTOR, (_col - OFFSET[1]) / ZOOM_FACTOR)
            grid_row.append(_coord)

        grid.append(grid_row)

    return grid

# def print_out(_grid, _name):
#     """
#     undocumented

#     """
#     _f = open(f"{_name}.txt", "a", encoding='UTF-8')
#     for _row in _grid:
#         _f.write(str(_row) + "\n")

def fractal(_z=Complex(_re=0, _im=0)):
    """
    computes the fractal exponent
    """

    return _z.exponential(2) + C        # C is the constant Complex number

def compute_jumps(_z=Complex(_re=0, _im=0)):
    """
    UNDOCUMENTED
    """
    iteration_count = 0

    while _z.magnitude() < THRESHOLD and iteration_count < 20:
        iteration_count += 1

        _z = _z.exponential(2) + C

    return iteration_count

MAX_ITERATION = 255



def julia(_z, _c=complex(0, 0)):
    """
    Calculate the number of iterations required for the Julia set function 
    to escape the threshold value for a given complex number.

    Args:
        _z (complex): The complex number to test.
        _c (complex, optional): The constant value used in the Julia set formula. Defaults to 0+0i.

    Returns:
        int:    The number of iterations required for the Julia set function 
                to escape the threshold value.
    """
    # Set the iteration count to 0.
    iteration_count = 0

    # Continue iterating while the absolute value (magnitude) of _z is less than a threshold
    # value and the iteration count is less than a maximum iteration value.
    while abs(_z) < THRESHOLD and iteration_count < MAX_ITERATION:
        # Update _z using the Julia set formula.
        _z = _z * _z + _c
        # Increment the iteration count.
        iteration_count += 1

    # Return the final iteration count.
    return iteration_count





def compute_shade(gray_scale):
    BASE_MULTIPLIER = 65025

def paint():
    """
    pygame playground
    """

    # print("one")
    grid = create_grid()
    # print("two")

    pygame.init()

    screen = pygame.display.set_mode(SCREEN_SIZE)
    screen.fill("Black")

    clock = pygame.time.Clock()
    # C = complex(-0.4, 0.6)
    C = complex(0, 0)

    for _row in range(GRID_SIZE[0]):
        for _col in range(GRID_SIZE[1]):
            shade = julia(grid[_row][_col], C)
            color = (shade, shade, shade)
            screen.set_at((_row, _col), color)

    for i in range(GRID_SIZE[0]):
        screen.set_at((int(OFFSET[1]), i), (255, 255, 255))
        screen.set_at((i, int(OFFSET[0])), (255, 255, 255))

    pygame.display.update()

    _xp = -0.04
    _yp = 0.06
    while True and _xp < 2 and _yp < 2:

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            # if event.type == pygame.MOUSEBUTTONDOWN:
            #     _x, _y = pygame.mouse.get_pos()
            #     C = complex((_x - OFFSET[0]) / (ZOOM_FACTOR), (_y - OFFSET[1]) / (ZOOM_FACTOR))

            #     print(C)
            #     screen.fill("Black")
            #     for _row in range(GRID_SIZE[0]):
            #         for _col in range(GRID_SIZE[1]):
            #             shade = julia(grid[_row][_col], C)
            #             # color = np.array([shade, shade, shade], dtype=np.uint8)
            #             color = (shade, shade, shade)
            #             screen.set_at((_row, _col), color)
                
            #     print(C)
            #     for i in range(GRID_SIZE[0]):
            #         screen.set_at((int(OFFSET[1]), i), (255, 255, 255))
            #         screen.set_at((i, int(OFFSET[0])), (255, 255, 255))
        screen.fill("Black")


        C = complex(_xp, _yp)

        for _row in range(GRID_SIZE[0]):
            for _col in range(GRID_SIZE[1]):
                shade = julia(grid[_row][_col], C)
                # color = np.array([shade, shade, shade], dtype=np.uint8)
                color = (shade, shade, shade)
                screen.set_at((_row, _col), color)
        
        print(C)
        for i in range(GRID_SIZE[0]):
            screen.set_at((int(OFFSET[1]), i), (255, 255, 255))
            screen.set_at((i, int(OFFSET[0])), (255, 255, 255))

        _xp -= 0.04
        _yp += 0.06

        pygame.display.update()
        clock.tick(1)

paint()
